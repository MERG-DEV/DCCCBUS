divert(-1)

define(output_check_changed_to,
       if $1 == $2 then
         report($3);
       else
         report("test_name: Output not changed to expected value");
         test_state := fail;
       end if;)

define(output_check_changed_from,
       if $1 != $2 then
         report($3);
       else
         report("test_name: Output not changed");
         test_state := fail;
       end if;)

define(output_wait_for_change,
       {ifelse($5, {}, {--}, report("test_name: Waiting $5 milliseconds for output change");)}
       {ifelse($5, {}, wait until $1 != $2;, wait until $1 != $2 for $5 ms;)}
       {output_check_changed_to($1, $3, $4)})

define(output_check_for_no_change,
       if $1 == $2 then
         report("test_name: Output unchanged");
       else
         report("test_name: Unexpected output change");
         test_state := fail;
       end if;)

define(output_wait_for_no_change,
       report("test_name: Waiting $3 milliseconds for no output change");
       wait until $1 != $2 for $3 ms;
       {output_check_for_no_change($1, $2)})

define(output_wait_for_output,
       {output_wait_for_change($1, 0, $2, $3, $4)})

define(output_wait_for_data_file_output,
       readline(data_file, output_report);
       while match(output_report, "Done") == false loop
         data_file_read(output_value)

         if match(output_report, "No change") then
           wait_until_idle
           --
           if $1 == last_output then
             report(output_report);
           else
             report("test_name: Unexpected output change");
             test_state := fail;
           end if;
         else
           output_wait_for_change($1, last_output, output_value, output_report)
         end if;
         --
         last_output := $1;
         readline(data_file, output_report);
       end loop;)

-- 16MHz clock = 4 instruction cycles per microsecond
define(u_sec, {eval($1 * 4)} ic)

define(dcc_one_half_time, 58)
define(dcc_zero_half_time, 100)

define(input_dcc_one,
       -- DCC One
       set_dcc_on
       wait for u_sec(dcc_one_half_time);
       set_dcc_off
       wait for u_sec(dcc_one_half_time);)

define(input_dcc_zero,
       -- DCC Zero
       set_dcc_on
       wait for u_sec(dcc_zero_half_time);
       set_dcc_off
       wait for u_sec(dcc_zero_half_time);)

define(input_dcc_bit, {ifelse($1, 1, input_dcc_one, input_dcc_zero)})

define(input_dcc_bits,
       {ifelse($1, {}, {}, input_dcc_bit(substr($1, 0, 1))
                           {input_dcc_bits(substr($1, 1))})})

define(input_dcc_complement, {ifelse($1, 0, input_dcc_one, input_dcc_zero)})

define(input_dcc_complements,
       {ifelse($1, {}, {}, input_dcc_complement(substr($1, 0, 1))
                           {input_dcc_complements(substr($1, 1))})})

define(input_dcc_preamble, input_dcc_bits(eval(14, 1)))

define(input_dcc_start,
       -- Preamble
       input_dcc_preamble()
       -- Preamble End
       input_dcc_zero)

define(input_dcc_basic_acc_event,
       -- Byte One
       input_dcc_one
       input_dcc_zero
       {input_dcc_bits(substr(eval($1 + 4, 2, 11), 3, 6))}
       -- Byte One End
       input_dcc_zero
       -- Byte Two
       input_dcc_one
       {input_dcc_bits(eval(7 - {0b}substr(eval($1 + 4, 2, 11), 0, 3), 2, 3))}
       -- Activation
       input_dcc_one
       -- Pair and Selection from Pair
       {input_dcc_bits(substr(eval($1 + 4, 2, 11), 9, 2))}
       {ifelse($2, Off, input_dcc_zero, input_dcc_one)}
       -- Byte Two End
       input_dcc_zero)

divert(0)dnl
